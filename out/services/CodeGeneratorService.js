"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeGeneratorService = void 0;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
class CodeGeneratorService {
    constructor(logger) {
        this.logger = logger;
    }
    async generateApexClasses(connection, options) {
        this.logger.info(`Generating Apex classes for: ${connection.name}`);
        const files = [];
        const className = this.sanitizeClassName(connection.name);
        // Generate main service class
        const serviceClass = this.generateServiceClass(connection, className, options);
        files.push(serviceClass);
        files.push(this.generateMetaXml(serviceClass.fileName, '60.0'));
        // Generate wrapper classes for request/response
        const wrapperClasses = this.generateWrapperClasses(connection, className);
        files.push(...wrapperClasses);
        // Generate test class if enabled
        if (options.generateTestClass) {
            const testClass = this.generateTestClass(connection, className, options);
            files.push(testClass);
            files.push(this.generateMetaXml(testClass.fileName, '60.0'));
        }
        // Generate mock service if enabled
        if (options.generateMockService) {
            const mockClass = this.generateMockClass(connection, className);
            files.push(mockClass);
            files.push(this.generateMetaXml(mockClass.fileName, '60.0'));
        }
        return files;
    }
    generateServiceClass(connection, className, options) {
        const serviceName = `${className}Service`;
        let content = `/**
 * ${connection.name} Integration Service
 * Auto-generated by Connectforce
 * 
 * Description: ${connection.description || 'External API integration service'}
 * Base URL: ${connection.baseUrl}
 * Generated: ${new Date().toISOString()}
 */
public with sharing class ${serviceName} {
    
    private static final String NAMED_CREDENTIAL = '${className}';
    private static final Integer DEFAULT_TIMEOUT = ${connection.timeout || 30000};
    
    /**
     * Custom exception for ${connection.name} API errors
     */
    public class ${className}Exception extends Exception {}
    
    /**
     * Response wrapper for API calls
     */
    public class ApiResponse {
        public Integer statusCode { get; set; }
        public String body { get; set; }
        public Boolean isSuccess { get; set; }
        public String errorMessage { get; set; }
        
        public ApiResponse(HttpResponse response) {
            this.statusCode = response.getStatusCode();
            this.body = response.getBody();
            this.isSuccess = response.getStatusCode() >= 200 && response.getStatusCode() < 300;
            if (!this.isSuccess) {
                this.errorMessage = 'HTTP ' + response.getStatusCode() + ': ' + response.getStatus();
            }
        }
    }
    
`;
        // Generate method for each endpoint
        for (const endpoint of connection.endpoints) {
            content += this.generateEndpointMethod(endpoint, className, options);
        }
        // Add helper methods
        content += `
    /**
     * Build HTTP request with common headers
     */
    private static HttpRequest buildRequest(String method, String endpoint) {
        HttpRequest req = new HttpRequest();
        req.setEndpoint('callout:' + NAMED_CREDENTIAL + endpoint);
        req.setMethod(method);
        req.setTimeout(DEFAULT_TIMEOUT);
        req.setHeader('Content-Type', 'application/json');
        req.setHeader('Accept', 'application/json');
        return req;
    }
    
    /**
     * Execute HTTP request with error handling
     */
    private static ApiResponse executeRequest(HttpRequest req) {
        Http http = new Http();
        try {
            HttpResponse response = http.send(req);
            return new ApiResponse(response);
        } catch (CalloutException e) {
            throw new ${className}Exception('Callout failed: ' + e.getMessage());
        }
    }
    
    /**
     * Execute request with retry logic
     */
    private static ApiResponse executeWithRetry(HttpRequest req, Integer maxRetries) {
        Integer attempts = 0;
        ApiResponse response;
        
        while (attempts < maxRetries) {
            attempts++;
            response = executeRequest(req);
            
            if (response.isSuccess || !isRetryableError(response.statusCode)) {
                return response;
            }
            
            // Wait before retry (simple backoff)
            if (attempts < maxRetries) {
                Long waitTime = (Long)Math.pow(2, attempts) * 1000;
                Long startTime = System.currentTimeMillis();
                while (System.currentTimeMillis() - startTime < waitTime) {
                    // Busy wait (limited options in Apex)
                }
            }
        }
        
        return response;
    }
    
    /**
     * Check if error is retryable
     */
    private static Boolean isRetryableError(Integer statusCode) {
        Set<Integer> retryableCodes = new Set<Integer>{500, 502, 503, 504, 429};
        return retryableCodes.contains(statusCode);
    }
`;
        // Add async methods if enabled
        if (options.asyncProcessing) {
            content += this.generateAsyncMethods(connection, className);
        }
        content += `
}`;
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('apexOutputPath', 'force-app/main/default/classes');
        return {
            fileName: `${serviceName}.cls`,
            content,
            type: 'apex',
            path: outputPath
        };
    }
    generateEndpointMethod(endpoint, className, options) {
        const methodName = this.sanitizeMethodName(endpoint.name);
        const hasBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method);
        const hasParams = endpoint.parameters && endpoint.parameters.length > 0;
        // Build method signature
        let params = [];
        if (hasParams) {
            for (const param of endpoint.parameters) {
                if (param.in === 'path' || param.in === 'query') {
                    params.push(`${this.convertToApexType(param.type)} ${this.sanitizeVariableName(param.name)}`);
                }
            }
        }
        if (hasBody && endpoint.requestBody) {
            const requestTypeName = `${this.sanitizeClassName(endpoint.name)}Request`;
            params.push(`${requestTypeName} requestBody`);
        }
        const responseTypeName = endpoint.responseSchema
            ? `${this.sanitizeClassName(endpoint.name)}Response`
            : 'ApiResponse';
        let method = `
    /**
     * ${endpoint.description || endpoint.name}
     * ${endpoint.method} ${endpoint.path}
     */
    public static ${responseTypeName} ${methodName}(${params.join(', ')}) {
        // Build endpoint path
        String endpointPath = '${endpoint.path}'`;
        // Handle path parameters
        if (hasParams) {
            for (const param of endpoint.parameters) {
                if (param.in === 'path') {
                    method += `
            .replace('{${param.name}}', EncodingUtil.urlEncode(String.valueOf(${this.sanitizeVariableName(param.name)}), 'UTF-8'))`;
                }
            }
        }
        method += `;
        
        // Handle query parameters
        List<String> queryParams = new List<String>();`;
        if (hasParams) {
            for (const param of endpoint.parameters) {
                if (param.in === 'query') {
                    const varName = this.sanitizeVariableName(param.name);
                    method += `
        if (${varName} != null) {
            queryParams.add('${param.name}=' + EncodingUtil.urlEncode(String.valueOf(${varName}), 'UTF-8'));
        }`;
                }
            }
        }
        method += `
        if (!queryParams.isEmpty()) {
            endpointPath += '?' + String.join(queryParams, '&');
        }
        
        // Build and send request
        HttpRequest req = buildRequest('${endpoint.method}', endpointPath);`;
        if (hasBody) {
            method += `
        if (requestBody != null) {
            req.setBody(JSON.serialize(requestBody));
        }`;
        }
        method += `
        
        ApiResponse apiResponse = executeRequest(req);
        
        if (!apiResponse.isSuccess) {
            throw new ${className}Exception(apiResponse.errorMessage);
        }`;
        if (endpoint.responseSchema) {
            method += `
        
        return (${responseTypeName})JSON.deserialize(apiResponse.body, ${responseTypeName}.class);`;
        }
        else {
            method += `
        
        return apiResponse;`;
        }
        method += `
    }
`;
        return method;
    }
    generateAsyncMethods(connection, className) {
        return `
    /**
     * Queueable class for async API calls
     */
    public class ${className}QueueableJob implements Queueable, Database.AllowsCallouts {
        private String methodName;
        private Map<String, Object> params;
        
        public ${className}QueueableJob(String methodName, Map<String, Object> params) {
            this.methodName = methodName;
            this.params = params;
        }
        
        public void execute(QueueableContext context) {
            // Execute the appropriate method based on methodName
            // Implementation depends on specific endpoints
        }
    }
    
    /**
     * Enqueue async job
     */
    public static Id enqueueJob(String methodName, Map<String, Object> params) {
        return System.enqueueJob(new ${className}QueueableJob(methodName, params));
    }
`;
    }
    generateWrapperClasses(connection, className) {
        const files = [];
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('apexOutputPath', 'force-app/main/default/classes');
        let wrapperContent = `/**
 * ${connection.name} Wrapper Classes
 * Auto-generated by Connectforce
 */
public class ${className}Types {
    
`;
        // Generate wrapper classes for each endpoint
        for (const endpoint of connection.endpoints) {
            const endpointClassName = this.sanitizeClassName(endpoint.name);
            // Request wrapper
            if (endpoint.requestBody) {
                wrapperContent += this.generateWrapperClass(`${endpointClassName}Request`, endpoint.requestBody);
            }
            // Response wrapper
            if (endpoint.responseSchema) {
                wrapperContent += this.generateWrapperClass(`${endpointClassName}Response`, endpoint.responseSchema);
            }
        }
        wrapperContent += `}`;
        files.push({
            fileName: `${className}Types.cls`,
            content: wrapperContent,
            type: 'apex',
            path: outputPath
        });
        files.push(this.generateMetaXml(`${className}Types.cls`, '60.0'));
        return files;
    }
    generateWrapperClass(name, schema) {
        let content = `
    /**
     * ${name} wrapper class
     */
    public class ${name} {`;
        if (schema.properties) {
            for (const [propName, prop] of Object.entries(schema.properties)) {
                const apexType = this.convertToApexType(prop.type, prop);
                const safeName = this.sanitizeVariableName(propName);
                content += `
        @AuraEnabled
        public ${apexType} ${safeName} { get; set; }`;
            }
        }
        content += `
        
        public ${name}() {}
    }
`;
        return content;
    }
    generateTestClass(connection, className, options) {
        const testClassName = `${className}ServiceTest`;
        const serviceName = `${className}Service`;
        let content = `/**
 * Test class for ${serviceName}
 * Auto-generated by Connectforce
 */
@isTest
private class ${testClassName} {
    
    /**
     * Setup test data
     */
    @TestSetup
    static void setupTestData() {
        // Add test data setup here
    }
    
    /**
     * Mock HTTP callout class
     */
    private class MockHttpResponseGenerator implements HttpCalloutMock {
        private Integer statusCode;
        private String body;
        
        public MockHttpResponseGenerator(Integer statusCode, String body) {
            this.statusCode = statusCode;
            this.body = body;
        }
        
        public HTTPResponse respond(HTTPRequest req) {
            HttpResponse res = new HttpResponse();
            res.setHeader('Content-Type', 'application/json');
            res.setBody(body);
            res.setStatusCode(statusCode);
            return res;
        }
    }
`;
        // Generate test methods for each endpoint
        for (const endpoint of connection.endpoints) {
            const methodName = this.sanitizeMethodName(endpoint.name);
            content += `
    /**
     * Test ${methodName} - Success scenario
     */
    @isTest
    static void test${this.capitalizeFirst(methodName)}Success() {
        // Setup mock response
        String mockResponse = '{"success": true}';
        Test.setMock(HttpCalloutMock.class, new MockHttpResponseGenerator(200, mockResponse));
        
        Test.startTest();
        // Call the method
        // ${serviceName}.${methodName}(...);
        Test.stopTest();
        
        // Add assertions
        System.assert(true, 'Test should pass');
    }
    
    /**
     * Test ${methodName} - Error scenario
     */
    @isTest
    static void test${this.capitalizeFirst(methodName)}Error() {
        // Setup mock error response
        String mockResponse = '{"error": "Not Found"}';
        Test.setMock(HttpCalloutMock.class, new MockHttpResponseGenerator(404, mockResponse));
        
        Test.startTest();
        try {
            // Call the method - should throw exception
            // ${serviceName}.${methodName}(...);
            System.assert(false, 'Should have thrown exception');
        } catch (${serviceName}.${className}Exception e) {
            System.assert(true, 'Exception thrown as expected');
        }
        Test.stopTest();
    }
`;
        }
        content += `
}`;
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('apexOutputPath', 'force-app/main/default/classes');
        return {
            fileName: `${testClassName}.cls`,
            content,
            type: 'apex',
            path: outputPath
        };
    }
    generateMockClass(connection, className) {
        const mockClassName = `${className}ServiceMock`;
        let content = `/**
 * Mock service for ${connection.name}
 * Auto-generated by Connectforce
 * Use this class for unit testing
 */
@isTest
public class ${mockClassName} implements HttpCalloutMock {
    
    private Map<String, MockResponse> responses;
    private List<HttpRequest> capturedRequests;
    
    public ${mockClassName}() {
        this.responses = new Map<String, MockResponse>();
        this.capturedRequests = new List<HttpRequest>();
        setupDefaultResponses();
    }
    
    /**
     * Mock response configuration
     */
    public class MockResponse {
        public Integer statusCode { get; set; }
        public String body { get; set; }
        public Map<String, String> headers { get; set; }
        
        public MockResponse(Integer statusCode, String body) {
            this.statusCode = statusCode;
            this.body = body;
            this.headers = new Map<String, String>();
        }
    }
    
    /**
     * Setup default mock responses for each endpoint
     */
    private void setupDefaultResponses() {`;
        // Add default responses for each endpoint
        for (const endpoint of connection.endpoints) {
            const key = `${endpoint.method}:${endpoint.path}`;
            content += `
        responses.put('${key}', new MockResponse(200, '{"success": true}'));`;
        }
        content += `
    }
    
    /**
     * Set custom response for an endpoint
     */
    public void setResponse(String method, String path, Integer statusCode, String body) {
        responses.put(method + ':' + path, new MockResponse(statusCode, body));
    }
    
    /**
     * Get captured requests for verification
     */
    public List<HttpRequest> getCapturedRequests() {
        return capturedRequests;
    }
    
    /**
     * HttpCalloutMock implementation
     */
    public HTTPResponse respond(HTTPRequest req) {
        capturedRequests.add(req);
        
        String endpoint = req.getEndpoint();
        String method = req.getMethod();
        
        // Find matching response
        for (String key : responses.keySet()) {
            String[] parts = key.split(':');
            if (parts[0] == method && endpoint.contains(parts[1])) {
                MockResponse mockResp = responses.get(key);
                
                HttpResponse res = new HttpResponse();
                res.setStatusCode(mockResp.statusCode);
                res.setBody(mockResp.body);
                res.setHeader('Content-Type', 'application/json');
                
                for (String header : mockResp.headers.keySet()) {
                    res.setHeader(header, mockResp.headers.get(header));
                }
                
                return res;
            }
        }
        
        // Default 404 response
        HttpResponse res = new HttpResponse();
        res.setStatusCode(404);
        res.setBody('{"error": "No mock configured for this endpoint"}');
        return res;
    }
}`;
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('apexOutputPath', 'force-app/main/default/classes');
        return {
            fileName: `${mockClassName}.cls`,
            content,
            type: 'apex',
            path: outputPath
        };
    }
    async generateNamedCredential(connection) {
        const credentialName = this.sanitizeClassName(connection.name);
        let principalType = 'Anonymous';
        let protocol = 'NoAuthentication';
        switch (connection.authenticationType) {
            case 'Basic':
                principalType = 'NamedUser';
                protocol = 'Password';
                break;
            case 'OAuth2':
                principalType = 'NamedUser';
                protocol = 'OAuth';
                break;
            case 'JWT':
                principalType = 'NamedUser';
                protocol = 'Jwt';
                break;
            case 'Certificate':
                principalType = 'NamedUser';
                protocol = 'Certificate';
                break;
        }
        const content = `<?xml version="1.0" encoding="UTF-8"?>
<NamedCredential xmlns="http://soap.sforce.com/2006/04/metadata">
    <allowMergeFieldsInBody>true</allowMergeFieldsInBody>
    <allowMergeFieldsInHeader>true</allowMergeFieldsInHeader>
    <calloutStatus>Enabled</calloutStatus>
    <endpoint>${connection.baseUrl}</endpoint>
    <generateAuthorizationHeader>true</generateAuthorizationHeader>
    <label>${connection.name}</label>
    <principalType>${principalType}</principalType>
    <protocol>${protocol}</protocol>
</NamedCredential>`;
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('namedCredentialPath', 'force-app/main/default/namedCredentials');
        return {
            fileName: `${credentialName}.namedCredential-meta.xml`,
            content,
            type: 'namedCredential',
            path: outputPath
        };
    }
    async generateExternalService(connection) {
        const files = [];
        const serviceName = this.sanitizeClassName(connection.name);
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('externalServicePath', 'force-app/main/default/externalServiceRegistrations');
        // Generate OpenAPI schema
        const openAPIService = await Promise.resolve().then(() => __importStar(require('./OpenAPIImportService')));
        const openAPIImporter = new openAPIService.OpenAPIImportService(this.logger);
        const schema = openAPIImporter.generateOpenAPISpec(connection);
        // External Service Registration
        const registrationContent = `<?xml version="1.0" encoding="UTF-8"?>
<ExternalServiceRegistration xmlns="http://soap.sforce.com/2006/04/metadata">
    <description>${connection.description || connection.name + ' External Service'}</description>
    <label>${connection.name}</label>
    <namedCredential>${serviceName}</namedCredential>
    <registrationProviderType>Custom</registrationProviderType>
    <schema><![CDATA[${schema}]]></schema>
    <schemaType>OpenApi3</schemaType>
    <serviceBinding>{&quot;host&quot;:&quot;${connection.baseUrl}&quot;}</serviceBinding>
    <status>Complete</status>
    <systemVersion>1</systemVersion>
</ExternalServiceRegistration>`;
        files.push({
            fileName: `${serviceName}.externalServiceRegistration-meta.xml`,
            content: registrationContent,
            type: 'externalService',
            path: outputPath
        });
        return files;
    }
    generateMetaXml(className, apiVersion) {
        const baseName = className.replace('.cls', '');
        const content = `<?xml version="1.0" encoding="UTF-8"?>
<ApexClass xmlns="http://soap.sforce.com/2006/04/metadata">
    <apiVersion>${apiVersion}</apiVersion>
    <status>Active</status>
</ApexClass>`;
        const config = vscode.workspace.getConfiguration('connectforce');
        const outputPath = config.get('apexOutputPath', 'force-app/main/default/classes');
        return {
            fileName: `${baseName}.cls-meta.xml`,
            content,
            type: 'meta-xml',
            path: outputPath
        };
    }
    async writeGeneratedFile(file) {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            throw new Error('No workspace folder open');
        }
        const workspaceRoot = workspaceFolders[0].uri.fsPath;
        // Sanitize file path to prevent path traversal
        const sanitizedPath = file.path.replace(/\.\./g, '').replace(/^\//, '');
        const sanitizedFileName = file.fileName.replace(/\.\./g, '').replace(/[<>:"|?*]/g, '');
        const fullPath = path.join(workspaceRoot, sanitizedPath);
        // Verify the resolved path is within workspace
        const resolvedPath = path.resolve(fullPath);
        if (!resolvedPath.startsWith(path.resolve(workspaceRoot))) {
            throw new Error('Invalid file path: path traversal detected');
        }
        // Ensure directory exists
        if (!fs.existsSync(fullPath)) {
            fs.mkdirSync(fullPath, { recursive: true });
        }
        const filePath = path.join(fullPath, sanitizedFileName);
        // Double-check final path is within workspace
        const resolvedFilePath = path.resolve(filePath);
        if (!resolvedFilePath.startsWith(path.resolve(workspaceRoot))) {
            throw new Error('Invalid file path: path traversal detected');
        }
        fs.writeFileSync(filePath, file.content, 'utf8');
        this.logger.info(`Written file: ${filePath}`);
        // Open the file in editor
        const document = await vscode.workspace.openTextDocument(filePath);
        await vscode.window.showTextDocument(document, { preview: false });
    }
    // Utility methods
    sanitizeClassName(name) {
        return name
            .replace(/[^a-zA-Z0-9]/g, '')
            .replace(/^[0-9]/, 'C$&');
    }
    sanitizeMethodName(name) {
        const sanitized = name
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .split(/\s+/)
            .map((word, index) => index === 0
            ? word.toLowerCase()
            : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
        return sanitized.replace(/^[0-9]/, 'm$&');
    }
    sanitizeVariableName(name) {
        const reserved = ['class', 'public', 'private', 'static', 'void', 'return', 'if', 'else',
            'for', 'while', 'do', 'break', 'continue', 'try', 'catch', 'finally',
            'throw', 'new', 'null', 'true', 'false', 'this', 'super'];
        let sanitized = name
            .replace(/[^a-zA-Z0-9_]/g, '_')
            .replace(/^[0-9]/, 'v$&');
        if (reserved.includes(sanitized.toLowerCase())) {
            sanitized = sanitized + 'Param';
        }
        return sanitized;
    }
    capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    convertToApexType(type, prop) {
        const typeMap = {
            'string': 'String',
            'number': 'Decimal',
            'integer': 'Integer',
            'boolean': 'Boolean',
            'date': 'Date',
            'datetime': 'Datetime',
            'array': 'List<Object>',
            'object': 'Map<String, Object>'
        };
        if (type === 'array' && prop?.items) {
            const itemType = this.convertToApexType(prop.items.type);
            return `List<${itemType}>`;
        }
        return typeMap[type] || 'Object';
    }
}
exports.CodeGeneratorService = CodeGeneratorService;
//# sourceMappingURL=CodeGeneratorService.js.map